---
title: "Learning to code for Ornament and Crime Hemisphere suite"
author: "Matt Crump"
date: "Last edited: `r format(Sys.time(), '%d %B, %Y')`"
twitter:
  card_description: "I'm making some notes on coding for the open-source eurorack module called Ornament and Crime"
  card_img: "https://crumplab.github.io/blogposts/7_28_20_OC/img/OC.png"
bibliography: refs.bib
csl: web/apa.csl
output: 
  html_document:
    template: web/template.html
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 3
    theme: yeti
    highlight: kate
    css: web/crump_basic.css
    includes:
      in_header: [web/header.html,web/g_analytics.html]
    md_extensions: -autolink_bare_uris
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

---

I don't really blog about synthesizers, but I like them, and I am slowly building a modular eurorack system. I've been playing around with [Ornament and Crime](https://ornament-and-cri.me), and then recently installed the alternative firmware [hemisphere suite](https://github.com/Chysn/O_C-HemisphereSuite/wiki) by Chysn. Both firmwares are very good. I forked the Hemisphere repo, and am now trying to code my own applets using the hemisphere approach. Using this page to make some notes as I go along.

I got started messing with O_C yesterday, and made some decent progress (although I don't really know C++, so it's slow going). 

I made a copy of the hemisphere source code and am modifying it in my own github repo <https://github.com/CrumpLab/O_C-MINERVA>. My basic plan is twofold. My overall goal is to start programming essentially weird versions of shift-register/turing machine style sequencers. Ultimately, I have plans to implement some computational models of human memory as eurorack sequencers, in particular Minerva II (Hintzman, 1984, 86, 88). But, to get there I need to learn how to do some more basic stuff.

My plan for learning is to systematically re-write my own version of the hemisphere suite to figure out what's going on, and then hopefully learn enough to start messing with it in musically interesting ways.

## Getting Started

It took about 2-3 hours before I was able to verify that I could modify the source code, compile it, and upload it to the unit and see that the pipeline was working. It should have been about 5-10 minutes, but I got stuck on stupid stuff. The instructions are clearly laid out on the original O_C site under method B for compiling firmware <https://ornament-and-cri.me/firmware/#method_b>. There are two methods, and they both word for installing the original or alternative firmwares. Method A involves loading a pre-compiled hex file. Method B compiles from source and then loads. I'm using method B, and in terms of development it works pretty seamlessly (e.g., you can keep the O_C hooked up by usb, and do one-click compile and upload whenever you want).

You need three things (links to software on method b link above)

1. download the arduino IDE 1.8.1
2. download Teensyduino v1.35
3. have a micro-usb cable to connect your computer to the O_C 

First install the Arduino IDE, then teensyduino, which will ask to install into your arduino app. NOTE: This is where I stupidly ran in a bunch of problems. I confused arduino IDE 1.8.10 for 1.8.1, and spent an hour or two trying to figure out why Teensyduino 1.35 (which is made for Arduino 1.8.1, NOT 1.8.10) wasn't installing. Yeesh. Anyway, I got it to install just fine once I had the correct versions (I'm on a Mac 10.14.6).

## Compiling and uploading

Step 2 of Method B is to have a copy of the firmware that you want to change. My impression is that the alternative firmware hemisphere suite will be easier for me to learn from, so I'm using that. I downloaded the source from github. Then you open `o_c_REV.ino` (in the software folder) in the arduino app. 

The next step is to set some preferences prior to compiling:

1) select teensy 3.2/3.1 in `Tools > Board.` and
2) select `MIDI > USB Type` (This is different from the original instructions, the hemisphere suite adds some midi functionality through USB, and it won't compile properly without this setting) . and
3) select 120MHz optimized (overclock) in `Tools > CPU Speed`. and
4) select Faster (= o2) in `Tools > Optimize` (teensyduino 1.34 and 1.35)

Finally, you need your O_C powered on through the eurorack power source, and you need to be connected to your computer by USB, then you can press `sketch > upload` in the Arduino app. This should compile then upload and restart the O_C. This process takes about 20 seconds or less usually. 

## General observations

I'm taking a combination of staring at the code and poking around various website to try and figure out how everything works. I haven't found any clear documentation anywhere, but I could have easily missed it. The code base is really well thought out, so it almost reads like an instruction manual.

[Chysn blogged about developing hemisphere suite](http://butmostlycrime.blogspot.com/2018/06/introducing-hemisphere.html), and there are numerous helpful tidbits there. He also has another repository with some tutorials on programming O_C firmware <https://github.com/Chysn/O_C_Tutorial1>. 

When you load the hemisphere suite firmware, you will get a bunch of "apps", including the hemisphere suite. For example, some of the apps are the game Pong, the darkest timeline (cool sequencer), ENIGMA (Turing machine variant), others, and hemisphere.

So, depending on what you want to do, you could write another "app" that gets added to this list and/or you could write additional modules/applets for the hemisphere suite. Right now I'm only focusing on modules for the hemisphere suite.

Hemisphere splits the O_C into two sides, and each side can load pretty much any of the applets. So, you could have the BootsNCats module loaded on one side to make kicks and snares, and a two channel euclidean sequencer on the other side controlling the kick and snare. Hemisphere has something like 51 different modules that can be loaded. Each side of hemisphere has one button, one endless encoder (with push), two gate inputs, two cv inputs, and two cv outputs, and half of a small screen for graphics.

## Brief code overview

Chysn provides the basic steps to write a new hemisphere module in `software/HEM_Boilerplate.ino.txt`, copied below. The short story is that all of the applets in hemisphere are listed as `HEM_Classname.ino` files in `software/o_c_REV`. You can add your own new ones, list them in `hemisphere_config.h`m and incremement `HEMISPHERE_AVAILABLE_APPLETS` to the new number of total apps. Then compile and upload. There are memory limitations, and this suite is already packed to the brim, so delete stuff as necessary. I'm super duper happy with the template for coding an applet. This one file takes care of everything, including the code for the display.

```
// Hemisphere Applet Boilerplate. Follow these steps to add a Hemisphere app:
//
// (1) Save this file as HEM_ClassName.ino
// (2) Find and replace "ClassName" with the name of your Applet class
// (3) Implement all of the public methods below
// (4) Add text to the help section below in SetHelp()
// (5) Add a declare line in hemisphere_config.h, which looks like this:
//     DECLARE_APPLET(id, categories, ClassName), \
// (6) Increment HEMISPHERE_AVAILABLE_APPLETS in hemisphere_config.h
// (7) Add your name and any additional copyright info to the block below

// Copyright (c) 2018, __________
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

class ClassName : public HemisphereApplet {
public:

    const char* applet_name() { // Maximum 10 characters
        return "ClassName";
    }

	/* Run when the Applet is selected */
    void Start() {
    }

	/* Run during the interrupt service routine, 16667 times per second */
    void Controller() {
    }

	/* Draw the screen */
    void View() {
        gfxHeader(applet_name());
        gfxSkyline();
        // Add other view code as private methods
    }

	/* Called when the encoder button for this hemisphere is pressed */
    void OnButtonPress() {
    }

	/* Called when the encoder for this hemisphere is rotated
	 * direction 1 is clockwise
	 * direction -1 is counterclockwise
	 */
    void OnEncoderMove(int direction) {
    }
        
    /* Each applet may save up to 32 bits of data. When data is requested from
     * the manager, OnDataRequest() packs it up (see HemisphereApplet::Pack()) and
     * returns it.
     */
    uint32_t OnDataRequest() {
        uint32_t data = 0;
        // example: pack property_name at bit 0, with size of 8 bits
        // Pack(data, PackLocation {0,8}, property_name); 
        return data;
    }

    /* When the applet is restored (from power-down state, etc.), the manager may
     * send data to the applet via OnDataReceive(). The applet should take the data
     * and unpack it (see HemisphereApplet::Unpack()) into zero or more of the applet's
     * properties.
     */
    void OnDataReceive(uint32_t data) {
        // example: unpack value at bit 0 with size of 8 bits to property_name
        // property_name = Unpack(data, PackLocation {0,8}); 
    }

protected:
    /* Set help text. Each help section can have up to 18 characters. Be concise! */
    void SetHelp() {
        //                               "------------------" <-- Size Guide
        help[HEMISPHERE_HELP_DIGITALS] = "Digital in help";
        help[HEMISPHERE_HELP_CVS]      = "CV in help";
        help[HEMISPHERE_HELP_OUTS]     = "Out help";
        help[HEMISPHERE_HELP_ENCODER]  = "123456789012345678";
        //                               "------------------" <-- Size Guide
    }
    
private:

};


////////////////////////////////////////////////////////////////////////////////
//// Hemisphere Applet Functions
///
///  Once you run the find-and-replace to make these refer to ClassName,
///  it's usually not necessary to do anything with these functions. You
///  should prefer to handle things in the HemisphereApplet child class
///  above.
////////////////////////////////////////////////////////////////////////////////
ClassName ClassName_instance[2];

void ClassName_Start(bool hemisphere) {ClassName_instance[hemisphere].BaseStart(hemisphere);}
void ClassName_Controller(bool hemisphere, bool forwarding) {ClassName_instance[hemisphere].BaseController(forwarding);}
void ClassName_View(bool hemisphere) {ClassName_instance[hemisphere].BaseView();}
void ClassName_OnButtonPress(bool hemisphere) {ClassName_instance[hemisphere].OnButtonPress();}
void ClassName_OnEncoderMove(bool hemisphere, int direction) {ClassName_instance[hemisphere].OnEncoderMove(direction);}
void ClassName_ToggleHelpScreen(bool hemisphere) {ClassName_instance[hemisphere].HelpScreen();}
uint32_t ClassName_OnDataRequest(bool hemisphere) {return ClassName_instance[hemisphere].OnDataRequest();}
void ClassName_OnDataReceive(bool hemisphere, uint32_t data) {ClassName_instance[hemisphere].OnDataReceive(data);}

```

## First attempts at coding

The first thing I did was try to make single change in the source that I could verify would compile correctly and not brick the O_C. I went into `HEM_BootsNCat.ino` and modified line 29-30 to change the `t` in Boots to a `p`.

```
    const char* applet_name() {
        return "BoopsNCat";
    }

```

Sure, enough, I press upload, scroll to that applet, and voila, it worked, and suddenly I feel like Jeff Bridges from TRON (the recent one where he says he "got in" in that Daft Punk song).





---


## References




